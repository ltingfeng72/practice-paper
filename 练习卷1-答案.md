# 练习卷1 答案

## 一、应用题（共 20 分，第 1 小题 10 分，第 2 小题 10 分）

### 1. 单链表操作

**1）给出在 p 结点(非尾结点)与其后继结点交换的操作？(4分)**

```c
// 方法：交换 p 结点和其后继结点的数据域
int temp = p->data;
p->data = p->next->data;
p->next->data = temp;
```

**2）写出采用尾插法由含有 n 个元素的数组 a 创建带头结点的单链表 L 的函数？(6分)**

```c
void CreateListR(LinkNode *&L, int a[], int n) {
    LinkNode *s, *r;
    L = (LinkNode *)malloc(sizeof(LinkNode));  // 创建头结点
    L->next = NULL;
    r = L;  // r 指向尾结点，初始为头结点
    
    for (int i = 0; i < n; i++) {
        s = (LinkNode *)malloc(sizeof(LinkNode));  // 创建新结点
        s->data = a[i];  // 赋值
        s->next = NULL;
        r->next = s;  // 将新结点链接到尾部
        r = s;  // r 指向新的尾结点
    }
}
```

## 二、应用题（共 20 分，第 1 小题 10 分，第 2 小题 10 分）

### 1. 二维数组存储

**计算 A[5][3] 的存储地址：**

按行优先顺序存储，A[i][j] 的地址计算公式为：
```
地址(A[i][j]) = 基地址 + ((i × 列数) + j) × 元素大小
```

对于 A[5][3]：
```
地址(A[5][3]) = 200 + ((5 × 30) + 3) × 2
              = 200 + (150 + 3) × 2
              = 200 + 153 × 2
              = 200 + 306
              = 506
```

**答案：506**

**上三角矩阵压缩存储的下标关系：**

按列优先顺序压缩存储上三角矩阵，A[i,j] (i ≤ j) 在一维数组 B 中的下标 k 为：
```
k = j × (j + 1) / 2 + i
```

### 2. 广义表操作

已知广义表 L = (a, (b, (c, d)), ((e, f), (g, h)))

**(1) head(tail(tail(L))) 的计算结果（4分）**

```
tail(L) = ((b, (c, d)), ((e, f), (g, h)))
tail(tail(L)) = (((e, f), (g, h)))
head(tail(tail(L))) = ((e, f), (g, h))
```

**答案：((e, f), (g, h))**

**(2) 计算该广义表的表头和表尾（4分）**

```
表头 head(L) = a
表尾 tail(L) = ((b, (c, d)), ((e, f), (g, h)))
```

**(3) 计算该广义表的深度（2分）**

分析各元素的嵌套层数：
- a: 深度 1
- (b, (c, d)): 深度 2
- ((e, f), (g, h)): 深度 3

**答案：深度为 3**

## 三、分析题（共 20 分，第 1 小题 10 分，第 2 小题 10 分）

### 1. 二叉树遍历

**注：由于 PDF 中缺少二叉树结构图，以下给出一般性答案**

**1）写出这棵二叉树的先序序列、中序序列、后序序列（6分）**

假设二叉树为：
```
       A
      / \
     B   C
    / \
   D   E
```

- **先序遍历（根-左-右）**：A B D E C
- **中序遍历（左-根-右）**：D B E A C
- **后序遍历（左-右-根）**：D E B C A

**2）将以上二叉树还原成森林（4分）**

将二叉树还原成森林的规则：
- 二叉树的根节点对应森林中第一棵树的根
- 左孩子对应树的第一个孩子
- 右兄弟对应树的下一个兄弟或森林中的下一棵树

还原后的森林：
```
树1: A
     |
     B
    / \
   D   E

树2: C
```

### 2. 栈操作

**顺序栈 a 的基本操作（栈顶下标按数组下标递增顺序进栈）**

```c
typedef struct {
    int data[MaxSize];
    int top;  // 栈顶指针
} SqStack;

// 判断栈空
bool StackEmpty(SqStack a) {
    return a.top == -1;
}

// 判断栈满
bool StackFull(SqStack a) {
    return a.top == MaxSize - 1;
}

// 将元素 e 进栈
bool Push(SqStack &a, int e) {
    if (a.top == MaxSize - 1) {
        return false;  // 栈满
    }
    a.top++;
    a.data[a.top] = e;
    return true;
}

// 出栈
bool Pop(SqStack &a, int &e) {
    if (a.top == -1) {
        return false;  // 栈空
    }
    e = a.data[a.top];
    a.top--;
    return true;
}
```

## 四、算法题（共 20 分，第 1 小题 10 分，第 2 小题 10 分）

### 1. 图中回路判断算法

```c
bool Cycle(ALGraph *G, int v) {
    visited[v] = 1;  // 标记为正在访问（灰色）
    
    ArcNode *p = G->adjlist[v].firstarc;  // 获取第一条边
    while (p != NULL) {
        int w = p->adjvex;  // 邻接顶点
        
        if (visited[w] == 0) {  // 未访问过
            if (Cycle(G, w)) {  // 递归访问
                return true;
            }
        } else if (visited[w] == 1) {  // 正在访问中，发现回路
            return true;
        }
        // 如果 visited[w] == 2，表示已完成访问，继续
        
        p = p->nextarc;  // 下一条边
    }
    
    visited[v] = 2;  // 标记为已完成访问（黑色）
    return false;
}

// 主函数调用
bool HasCycle(ALGraph *G) {
    // 初始化 visited 数组：0-未访问，1-正在访问，2-已完成
    for (int i = 0; i < G->n; i++) {
        visited[i] = 0;
    }
    
    // 对所有未访问的顶点进行 DFS
    for (int i = 0; i < G->n; i++) {
        if (visited[i] == 0) {
            if (Cycle(G, i)) {
                return true;
            }
        }
    }
    return false;
}
```

### 2. 平衡二叉树构造

**输入序列：{16, 3, 7, 11, 9, 26, 18, 14, 15}**

**(1) 构造平衡二叉树的步骤（6分）**

```
步骤1：插入 16
       16

步骤2：插入 3
       16
      /
     3

步骤3：插入 7
       16
      /
     3
      \
       7
平衡因子检查：OK

步骤4：插入 11
        16
       /
      3
       \
        7
         \
         11
不平衡！在节点3处，需要左旋转
调整后：
        16
       /
      7
     / \
    3  11

步骤5：插入 9
        16
       /
      7
     / \
    3  11
       /
      9

步骤6：插入 26
        16
       /  \
      7    26
     / \
    3  11
       /
      9

步骤7：插入 18
        16
       /  \
      7    26
     / \   /
    3  11 18
       /
      9

步骤8：插入 14
        16
       /  \
      7    26
     / \   /
    3  11 18
       / \
      9  14
不平衡！在节点11处
调整后：
        16
       /  \
      7    26
     / \   /
    3  11 18
       / \
      9  14

步骤9：插入 15
        16
       /  \
      7    26
     / \   /
    3  11 18
       / \
      9  14
          \
          15
不平衡！需要调整
最终平衡二叉树：
         11
       /    \
      7      16
     / \    /  \
    3   9  14  26
            / \
           /   \
          /     18
         15
```

**(2) 平均查找长度（4分）**

最终平衡二叉树结构：
```
          11(1)
        /      \
      7(2)      16(2)
     / \        /  \
   3(3) 9(3) 14(3) 26(3)
              /
            15(4)
              \
              18(5)
```

**查找成功的平均查找长度 ASL_{success}：**
```
ASL_success = (1×1 + 2×2 + 3×4 + 4×1 + 5×1) / 9
            = (1 + 4 + 12 + 4 + 5) / 9
            = 26 / 9
            ≈ 2.89
```

**查找不成功的平均查找长度 ASL_{fail}：**
外部节点数为10个，分别在深度4和5
```
ASL_fail = (4×6 + 5×4) / 10
         = (24 + 20) / 10
         = 44 / 10
         = 4.4
```

## 五、综合题（共 20 分，第 1 小题 10 分，第 2 小题 10 分）

### 1. 排序算法

**1）内排序和外排序的区别（3分）**

- **内排序**：排序过程中，所有记录都在内存中进行。适用于数据量较小的情况。
- **外排序**：排序过程中，由于数据量太大，无法全部装入内存，需要借助外部存储器（如磁盘）进行排序。

主要区别：
1. 数据存储位置：内排序在内存，外排序涉及内存和外存
2. 处理数据量：内排序处理小数据量，外排序处理大数据量
3. 时间复杂度：内排序主要考虑比较和移动次数，外排序主要考虑I/O次数

**2）简单选择排序过程及算法实现（7分）**

**关键字序列：{6, 8, 7, 9, 0, 1, 3, 2, 4, 5}**

排序过程：
```
初始序列：    6  8  7  9  0  1  3  2  4  5
第1趟排序：   0| 8  7  9  6  1  3  2  4  5  （选择最小的0，与第1个位置交换）
第2趟排序：   0  1| 7  9  6  8  3  2  4  5  （选择最小的1，与第2个位置交换）
第3趟排序：   0  1  2| 9  6  8  3  7  4  5  （选择最小的2，与第3个位置交换）
第4趟排序：   0  1  2  3| 6  8  9  7  4  5  （选择最小的3，与第4个位置交换）
第5趟排序：   0  1  2  3  4| 8  9  7  6  5  （选择最小的4，与第5个位置交换）
第6趟排序：   0  1  2  3  4  5| 9  7  6  8  （选择最小的5，与第6个位置交换）
第7趟排序：   0  1  2  3  4  5  6| 7  9  8  （选择最小的6，与第7个位置交换）
第8趟排序：   0  1  2  3  4  5  6  7| 9  8  （选择最小的7，与第8个位置交换）
第9趟排序：   0  1  2  3  4  5  6  7  8| 9  （选择最小的8，与第9个位置交换）
最终结果：    0  1  2  3  4  5  6  7  8  9
```

**算法实现：**
```c
void SelectSort(int R[], int n) {
    int i, j, k, temp;
    
    for (i = 0; i < n - 1; i++) {  // 进行 n-1 趟排序
        k = i;  // k 记录最小元素的下标
        
        // 在 R[i...n-1] 中查找最小元素
        for (j = i + 1; j < n; j++) {
            if (R[j] < R[k]) {
                k = j;  // 更新最小元素下标
            }
        }
        
        // 将最小元素与第 i 个位置的元素交换
        if (k != i) {
            temp = R[i];
            R[i] = R[k];
            R[k] = temp;
        }
    }
}
```

### 2. 快速排序

**数组 R：{6, 2, 9, 7, 3, 8, 4, 5, 0, 10}**

**(1) 第一次划分操作后的结果（3分）**

取第一个元素 6 作为基准（pivot）：

```
初始：    6  2  9  7  3  8  4  5  0  10
         pivot=6, i=0, j=9

过程：
j从右向左找小于6的：0 (j=8)
i从左向右找大于6的：9 (i=2)
交换：    6  2  0  7  3  8  4  5  9  10

j从右向左找小于6的：5 (j=7)
i从左向右找大于6的：7 (i=3)
交换：    6  2  0  5  3  8  4  7  9  10

j从右向左找小于6的：4 (j=6)
i从左向右找大于6的：8 (i=5)
交换：    6  2  0  5  3  4  8  7  9  10

j从右向左找小于6的：3 (j=4)
i从左向右找大于6的：8 (i=5)
i>=j，结束

将基准6与j位置的元素交换：
结果：    3  2  0  5  4  6  8  7  9  10
```

**答案：{3, 2, 0, 5, 4, 6, 8, 7, 9, 10}**
（基准6左边的都小于等于6，右边的都大于等于6）

**(2) 快速排序一次划分的函数实现（7分）**

```c
void Partition(int R[], int n) {
    int pivot = R[0];  // 选取第一个元素作为基准
    int i = 0;
    int j = n - 1;
    int temp;
    
    while (i < j) {
        // 从右向左找第一个小于基准的元素
        while (i < j && R[j] >= pivot) {
            j--;
        }
        
        // 从左向右找第一个大于基准的元素
        while (i < j && R[i] <= pivot) {
            i++;
        }
        
        // 交换 R[i] 和 R[j]
        if (i < j) {
            temp = R[i];
            R[i] = R[j];
            R[j] = temp;
        }
    }
    
    // 将基准元素放到正确位置
    temp = R[0];
    R[0] = R[i];
    R[i] = temp;
}
```

---

**答案完成日期：** 2025年12月23日
